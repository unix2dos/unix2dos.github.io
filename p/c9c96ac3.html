<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.9.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"www.liuvv.com",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1,dimmer:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.json"}</script><meta name="description" content="1. Systemd1.1 前言历史上，Linux 的启动一直采用init进程。 Systemd 设计目标是，为系统的启动和管理提供一套完整的解决方案。Systemd 是一系列工具的集合，其作用也远远不仅是启动操作系统，它还接管了后台服务、结束、状态查询，以及日志归档、设备管理、电源管理、定时任务等许多职责，并支持通过特定事件（如插入特定 USB 设备）和特定端口数据触发的 On-demand（按"><meta name="keywords" content="linux,systemctl"><meta property="og:type" content="article"><meta property="og:title" content="systemd和systemctl详解"><meta property="og:url" content="https://www.liuvv.com/p/c9c96ac3.html"><meta property="og:site_name" content="Levonfly&#39;s Blog"><meta property="og:description" content="1. Systemd1.1 前言历史上，Linux 的启动一直采用init进程。 Systemd 设计目标是，为系统的启动和管理提供一套完整的解决方案。Systemd 是一系列工具的集合，其作用也远远不仅是启动操作系统，它还接管了后台服务、结束、状态查询，以及日志归档、设备管理、电源管理、定时任务等许多职责，并支持通过特定事件（如插入特定 USB 设备）和特定端口数据触发的 On-demand（按"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2021-01-29T16:18:40.990Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="systemd和systemctl详解"><meta name="twitter:description" content="1. Systemd1.1 前言历史上，Linux 的启动一直采用init进程。 Systemd 设计目标是，为系统的启动和管理提供一套完整的解决方案。Systemd 是一系列工具的集合，其作用也远远不仅是启动操作系统，它还接管了后台服务、结束、状态查询，以及日志归档、设备管理、电源管理、定时任务等许多职责，并支持通过特定事件（如插入特定 USB 设备）和特定端口数据触发的 On-demand（按"><link rel="canonical" href="https://www.liuvv.com/p/c9c96ac3.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>systemd和systemctl详解 | Levonfly's Blog</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Levonfly's Blog</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">微信: L6241425</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>日志</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><a href="https://github.com/unix2dos" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.liuvv.com/p/c9c96ac3.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="levonfly"><meta itemprop="description" content="Keep it simple, stupid."></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Levonfly's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">systemd和systemctl详解</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-01-28 00:00:00" itemprop="dateCreated datePublished" datetime="2021-01-28T00:00:00+08:00">2021-01-28</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-01-30 00:18:40" itemprop="dateModified" datetime="2021-01-30T00:18:40+08:00">2021-01-30</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/2-linux系统/" itemprop="url" rel="index"><span itemprop="name">2-linux系统</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/2-linux系统/系统/" itemprop="url" rel="index"><span itemprop="name">系统</span></a> </span></span><span id="/p/c9c96ac3.html" class="post-meta-item leancloud_visitors" data-flag-title="systemd和systemctl详解" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/p/c9c96ac3.html#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/p/c9c96ac3.html" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>13k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>12 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="1-Systemd"><a href="#1-Systemd" class="headerlink" title="1. Systemd"></a>1. Systemd</h1><h3 id="1-1-前言"><a href="#1-1-前言" class="headerlink" title="1.1 前言"></a>1.1 前言</h3><p>历史上，Linux 的启动一直采用init进程。 Systemd 设计目标是，为系统的启动和管理提供一套完整的解决方案。</p><p>Systemd 是一系列工具的集合，其作用也远远不仅是启动操作系统，它还接管了后台服务、结束、状态查询，以及日志归档、设备管理、电源管理、定时任务等许多职责，并支持通过特定事件（如插入特定 USB 设备）和特定端口数据触发的 On-demand（按需）任务。</p><p>Systemd 的后台服务还有一个特殊的身份——它是系统中 PID 值为 1 的进程。</p><a id="more"></a><h3 id="1-2-特点"><a href="#1-2-特点" class="headerlink" title="1.2 特点"></a>1.2 特点</h3><ul><li><p>更少的进程</p><p>Systemd 提供了 服务按需启动 的能力，使得特定的服务只有在真定被请求时才启动。</p></li><li><p>允许更多的进程并行启动</p><p>在 SysV-init 时代，将每个服务项目编号依次执行启动脚本。Ubuntu 的 Upstart 解决了没有直接依赖的启动之间的并行启动。而 Systemd 通过 Socket 缓存、DBus 缓存和建立临时挂载点等方法进一步解决了启动进程之间的依赖，做到了所有系统服务并发启动。对于用户自定义的服务，Systemd 允许配置其启动依赖项目，从而确保服务按必要的顺序运行。</p></li><li><p>使用 CGroup 跟踪和管理进程的生命周期</p><p>在 Systemd 之间的主流应用管理服务都是使用 进程树 来跟踪应用的继承关系的，而进程的父子关系很容易通过 两次 fork 的方法脱离。</p><p>而 Systemd 则提供通过 CGroup 跟踪进程关系，引补了这个缺漏。通过 CGroup 不仅能够实现服务之间访问隔离，限制特定应用程序对系统资源的访问配额，还能更精确地管理服务的生命周期。</p></li><li><p>统一管理服务日志</p><p>Systemd 是一系列工具的集合， 包括了一个专用的系统日志管理服务：Journald。这个服务的设计初衷是克服现有 Syslog 服务的日志内容易伪造和日志格式不统一等缺点，Journald 用 二进制格式 保存所有的日志信息，因而日志内容很难被手工伪造。Journald 还提供了一个 journalctl 命令来查看日志信息，这样就使得不同服务输出的日志具有相同的排版格式， 便于数据的二次处理。</p></li></ul><h3 id="1-3-Unit-和-Target"><a href="#1-3-Unit-和-Target" class="headerlink" title="1.3 Unit 和 Target"></a>1.3 Unit 和 Target</h3><p>Unit 是 Systemd 管理系统资源的基本单元，可以认为每个系统资源就是一个 Unit，并使用一个 Unit 文件定义。在 Unit 文件中需要包含相应服务的描述、属性以及需要运行的命令。</p><p>Target 是 Systemd 中用于指定系统资源启动组的方式，相当于 SysV-init 中的运行级别。</p><p>简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于”状态点”，启动某个 Target 就好比启动到某种状态。</p><h3 id="1-4-Systemd-目录"><a href="#1-4-Systemd-目录" class="headerlink" title="1.4 Systemd 目录"></a>1.4 Systemd 目录</h3><p>Unit 文件按照 Systemd 约定，应该被放置指定的三个系统目录之一中。这三个目录是有优先级的，如下所示，越靠上的优先级越高。因此，在三个目录中有同名文件的时候，只有优先级最高的目录里的那个文件会被使用。</p><ul><li>/etc/systemd/system：系统或用户自定义的配置文件</li><li>/run/systemd/system：软件运行时生成的配置文件</li><li>/usr/lib/systemd/system：系统或第三方软件安装时添加的配置文件。</li></ul><p>Systemd 默认从目录 /etc/systemd/system/ 读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录 /usr/lib/systemd/system/，真正的配置文件存放在那个目录。</p><h1 id="2-Unit"><a href="#2-Unit" class="headerlink" title="2. Unit"></a>2. Unit</h1><p>Systemd 可以管理所有系统资源：将系统资源划分为12类。将每个系统资源称为一个 Unit。</p><p>Unit 是 Systemd 管理系统资源的基本单位。使用一个 Unit File 作为 Unit 的单元文件，Systemd 通过单元文件控制 Unit 的启动。</p><p>例如，MySQL服务被 Systemd 视为一个 Unit，使用一个 mysql.service 作为启动配置文件</p><h3 id="2-1-Unit-File"><a href="#2-1-Unit-File" class="headerlink" title="2.1 Unit File"></a>2.1 Unit File</h3><p>Systemd 将系统资源划分为12类，对应12种类型的单元文件</p><table><thead><tr><th>系统资源类型</th><th>单元文件扩展名</th><th>单元文件描述</th></tr></thead><tbody><tr><td>Service</td><td>.service</td><td>封装守护进程的启动、停止、重启和重载操作，是最常见的一种 Unit 文件</td></tr><tr><td>Target</td><td>.target</td><td>定义 target 信息及依赖关系，一般仅包含 Unit 段</td></tr><tr><td>Device</td><td>.device</td><td>对于 <code>/dev</code> 目录下的硬件设备，主要用于定义设备之间的依赖关系</td></tr><tr><td>Mount</td><td>.mount</td><td>定义文件系统的挂载点，可以替代过去的 <code>/etc/fstab</code> 配置文件</td></tr><tr><td>Automount</td><td>.automount</td><td>用于控制自动挂载文件系统，相当于 SysV-init 的 autofs 服务</td></tr><tr><td>Path</td><td>.path</td><td>用于监控指定目录或文件的变化，并触发其它 Unit 运行</td></tr><tr><td>Scope</td><td>.scope</td><td>这种 Unit 文件不是用户创建的，而是 Systemd 运行时产生的，描述一些系统服务的分组信息</td></tr><tr><td>Slice</td><td>.slice</td><td>用于表示一个 CGroup 的树</td></tr><tr><td>Snapshot</td><td>.snapshot</td><td>用于表示一个由 systemctl snapshot 命令创建的 Systemd Units 运行状态快照，可以切回某个快照</td></tr><tr><td>Socket</td><td>.socket</td><td>监控来自于系统或网络的数据消息</td></tr><tr><td>Swap</td><td>.swap</td><td>定义一个用户做虚拟内存的交换分区</td></tr><tr><td>Timer</td><td>.timer</td><td>用于配置在特定时间触发的任务，替代了 Crontab 的功能</td></tr></tbody></table><p>对于操作单元文件的命令，如果缺省扩展名，则默认<code>.service</code>扩展名</p><h3 id="2-2-语法"><a href="#2-2-语法" class="headerlink" title="2.2 语法"></a>2.2 语法</h3><p>先看一个示例</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=Hello World</span><br><span class="line"><span class="attr">After</span>=docker.service</span><br><span class="line"><span class="attr">Requires</span>=docker.service</span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">TimeoutStartSec</span>=<span class="number">0</span></span><br><span class="line"><span class="attr">ExecStartPre</span>=-/usr/bin/docker kill busybox1</span><br><span class="line"><span class="attr">ExecStartPre</span>=-/usr/bin/docker rm busybox1</span><br><span class="line"><span class="attr">ExecStartPre</span>=/usr/bin/docker pull busybox</span><br><span class="line"><span class="attr">ExecStart</span>=/usr/bin/docker run --name busybox1 busybox /bin/ sh -c <span class="string">"while true; do echo Hello World; sleep 1; done"</span></span><br><span class="line"><span class="attr">ExecStop</span>=<span class="string">"/usr/bin/docker stop busybox1"</span></span><br><span class="line"><span class="attr">ExecStopPost</span>=<span class="string">"/usr/bin/docker rm busybox1"</span></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure><p>Unit 文件可以分为三个配置区段：</p><ul><li>Unit 段：所有 Unit 文件通用，用来定义 Unit 的元数据，以及配置与其他 Unit 的关系</li><li>Service 段：服务（Service）类型的 Unit 文件（后缀为 .service）特有的，用于定义服务的具体管理和执行动作</li><li>Install 段：所有 Unit 文件通用，用来定义如何启动，以及是否开机启动</li></ul><p>Unit 和 Install 段：所有 Unit 文件通用，用于配置服务（或其它系统资源）的描述、依赖和随系统启动的方式</p><p>Service 段：服务（Service）类型的 Unit 文件（后缀为 .service）特有的，用于定义服务的具体管理和操作方法</p><p>单元文件中的区段名和字段名大小写敏感, 每个区段内都是一些等号连接的键值对（键值对的等号两侧不能有空格）</p><h3 id="2-3-Unit-段"><a href="#2-3-Unit-段" class="headerlink" title="2.3 Unit 段"></a>2.3 Unit 段</h3><ul><li><code>Description</code>：当前服务的简单描述</li><li><code>Documentation</code>：文档地址，可以是一个或多个文档的 URL 路径</li><li><code>Requires</code>：与其它 Unit 的强依赖关系，如果其中任意一个 Unit 启动失败或异常退出，当前 Unit 也会被退出</li><li><code>Wants</code>：与其它 Unit 的弱依赖关系，如果其中任意一个 Unit 启动失败或异常退出，不影响当前 Unit 继续执行</li><li><code>After</code>：该字段指定的 Unit 全部启动完成以后，才会启动当前 Unit</li><li><code>Before</code>：该字段指定的 Unit 必须在当前 Unit 启动完成之后再启动</li><li><code>Binds To</code>：与 Requires 相似，该字段指定的 Unit 如果退出，会导致当前 Unit 停止运行</li><li><code>Part Of</code>：一个 Bind To 作用的子集，仅在列出的 Unit 失败或重启时，终止或重启当前 Unit，而不会随列出Unit 的启动而启动</li><li><code>OnFailure</code>：当这个模板启动失败时，就会自动启动列出的每个模块</li><li><code>Conflicts</code>：与这个模块有冲突的模块，如果列出的模块中有已经在运行的，这个服务就不能启动，反之亦然</li></ul><h3 id="2-4-Install段"><a href="#2-4-Install段" class="headerlink" title="2.4 Install段"></a>2.4 Install段</h3><p>这部分配置的目标模块通常是特定运行目标的 .target 文件，用来使得服务在系统启动时自动运行。</p><ul><li><p><code>WantedBy</code>：它的值是一个或多个 target，执行enable命令时，符号链接会放入<code>/etc/systemd/system</code>目录下以 target 名 + <code>.wants</code>后缀构成的子目录中</p></li><li><p><code>RequiredBy</code>：它的值是一个或多个 target，执行enable命令时，符号链接会放入<code>/etc/systemd/system</code>目录下以 target 名 + <code>.required</code>后缀构成的子目录中</p></li><li><p><code>Alias</code>：当前 Unit 可用于启动的别名</p></li><li><p><code>Also</code>：当前 Unit 被 enable/disable 时，会被同时操作的其他 Unit</p></li></ul><h3 id="2-5-Service段"><a href="#2-5-Service段" class="headerlink" title="2.5 Service段"></a>2.5 Service段</h3><p>用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。</p><p>所有的启动设置之前，都可以加上一个连词号（<code>-</code>），表示”抑制错误”，即发生错误的时候，不影响其他命令的执行。</p><p>比如，<code>EnvironmentFile=-/etc/sysconfig/sshd</code>（注意等号后面的那个连词号），就表示即使<code>/etc/sysconfig/sshd</code>文件不存在，也不会抛出错误。</p><h5 id="2-5-1-启动类型"><a href="#2-5-1-启动类型" class="headerlink" title="2.5.1 启动类型"></a>2.5.1 启动类型</h5><ul><li><p>Type：定义启动时的进程行为。它有以下几种值。</p><p><strong>Type=simple</strong>：默认值，ExecStart字段启动的进程为主进程<br>服务进程不会 fork，如果该服务要启动其他服务，不要使用此类型启动，除非该服务是 socket 激活型</p><p><strong>Type=forking</strong>：ExecStart字段将以fork()方式从父进程创建子进程启动，创建后父进程会立即退出，子进程成为主进程。<br>通常需要指定PIDFile字段，以便 Systemd 能够跟踪服务的主进程</p><p>对于常规的守护进程（daemon），除非你确定此启动方式无法满足需求，使用此类型启动即可</p><p><strong>Type=oneshot</strong>：只执行一次，Systemd 会等当前服务退出，再继续往下执行, 适用于只执行一项任务、随后立即退出的服务<br>通常需要指定RemainAfterExit=yes字段，使得 Systemd 在服务进程退出之后仍然认为服务处于激活状态</p><p><strong>Type=dbus</strong>：当前服务通过 D-Bus 信号启动。当指定的 BusName 出现在 DBus 系统总线上时，Systemd认为服务就绪</p><p><strong>Type=notify</strong>：当前服务启动完毕会发出通知信号，通知 Systemd，然后 Systemd 再启动其他服务</p><p><strong>Type=idle</strong>：Systemd 会等到其他任务都执行完，才会启动该服务。一种使用场合是：让该服务的输出，不与其他服务的输出相混合</p><h5 id="2-5-2-启动行为"><a href="#2-5-2-启动行为" class="headerlink" title="2.5.2 启动行为"></a>2.5.2 启动行为</h5></li><li><p><code>ExecStart</code>：启动当前服务的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/bin/<span class="built_in">echo</span> execstart1</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=/bin/<span class="built_in">echo</span> execstart2</span><br></pre></td></tr></table></figure><p>顺序执行设定的命令，把字段置空，表示清除之前的值</p></li></ul><ul><li><code>ExecStartPre</code>：启动当前服务之前执行的命令</li><li><code>ExecStartPost</code>：启动当前服务之后执行的命令</li><li><code>ExecReload</code>：重启当前服务时执行的命令</li><li><code>ExecStop</code>：停止当前服务时执行的命令</li><li><code>ExecStopPost</code>：停止当前服务之后执行的命令</li><li><code>RemainAfterExit</code>：当前服务的所有进程都退出的时候，Systemd 仍认为该服务是激活状态, 这个配置主要是提供给一些并非常驻内存，而是启动注册后立即退出，然后等待消息按需启动的特殊类型服务使用的</li></ul><ul><li><code>TimeoutSec</code>：定义 Systemd 停止当前服务之前等待的秒数</li></ul><h5 id="2-5-3-重启行为"><a href="#2-5-3-重启行为" class="headerlink" title="2.5.3 重启行为"></a>2.5.3 重启行为</h5><ul><li><code>RestartSec</code>：Systemd 重启当前服务间隔的秒数</li><li><code>KillMode</code>：定义 Systemd 如何停止服务，可能的值包括：<br>control-group（默认值）：当前控制组里面的所有子进程，都会被杀掉<br>process：只杀主进程（sshd 服务，推荐值）<br>mixed：主进程将收到 SIGTERM 信号，子进程收到 SIGKILL 信号<br>none：没有进程会被杀掉，只是执行服务的 stop 命令。</li><li><code>Restart</code>：定义何种情况 Systemd 会自动重启当前服务，可能的值包括：<br>no（默认值）：退出后不会重启<br>on-success：只有正常退出时（退出状态码为0），才会重启<br>on-failure：非正常退出时（退出状态码非0），包括被信号终止和超时，才会重启（守护进程，推荐值）<br>on-abnormal：只有被信号终止和超时，才会重启（对于允许发生错误退出的服务，推荐值）<br>on-abort：只有在收到没有捕捉到的信号终止时，才会重启<br>on-watchdog：超时退出，才会重启<br>always：不管是什么退出原因，总是重启</li></ul><h5 id="2-5-4-上下文"><a href="#2-5-4-上下文" class="headerlink" title="2.5.4 上下文"></a>2.5.4 上下文</h5><ul><li><p><code>PIDFile</code>：指向当前服务 PID file 的绝对路径。</p></li><li><p><code>User</code>：指定运行服务的用户</p></li><li><p><code>Group</code>：指定运行服务的用户组</p></li><li><p><code>EnvironmentFile</code>：指定当前服务的环境参数文件。该文件内部的<code>key=value</code>键值对，可以用<code>$key</code>的形式，在当前配置文件中获取</p><p>启动<code>sshd</code>，执行的命令是<code>/usr/sbin/sshd -D $OPTIONS</code>，其中的变量<code>$OPTIONS</code>就来自<code>EnvironmentFile</code>字段指定的环境参数文件。</p></li></ul><h3 id="2-6-占位符"><a href="#2-6-占位符" class="headerlink" title="2.6 占位符"></a>2.6 占位符</h3><p>在 Unit 文件中，有时会需要使用到一些与运行环境有关的信息，例如节点 ID、运行服务的用户等。这些信息可以使用占位符来表示，然后在实际运行中动态地替换为实际的值。</p><ul><li>%n：完整的 Unit 文件名字，包括 .service 后缀名</li><li>%p：Unit 模板文件名中 @ 符号之前的部分，不包括 @ 符号</li><li>%i：Unit 模板文件名中 @ 符号之后的部分，不包括 @ 符号和 .service 后缀名</li><li>%t：存放系统运行文件的目录，通常是 “run”</li><li>%u：运行服务的用户，如果 Unit 文件中没有指定，则默认为 root</li><li>%U：运行服务的用户 ID</li><li>%h：运行服务的用户 Home 目录，即 %{HOME} 环境变量的值</li><li>%s：运行服务的用户默认 Shell 类型，即 %{SHELL} 环境变量的值</li><li>%m：实际运行节点的 Machine ID，对于运行位置每个的服务比较有用</li><li>%b：Boot ID，这是一个随机数，每个节点各不相同，并且每次节点重启时都会改变</li><li>%H：实际运行节点的主机名</li><li>%v：内核版本，即 “uname -r” 命令输出的内容</li><li>%%：在 Unit 模板文件中表示一个普通的百分号</li></ul><h3 id="2-7-模板"><a href="#2-7-模板" class="headerlink" title="2.7 模板"></a>2.7 模板</h3><p>在现实中，往往有一些应用需要被复制多份运行，就会用到模板文件</p><p>模板文件的写法与普通单元文件基本相同，只是模板文件名是以 @ 符号结尾。例如：apache@.service</p><p>通过模板文件启动服务实例时，需要在其文件名的 @ 字符后面附加一个用于区分服务实例的参数字符串，通常这个参数是用于监控的端口号或控制台 TTY 编译号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start apache@8080.service</span><br></pre></td></tr></table></figure><p>Systemd 在运行服务时，首先寻找跟单元名完全匹配的单元文件，如果没有找到，才会尝试选择匹配模板</p><p>例如上面的命令，System 首先会在约定的目录下寻找名为 <a href="mailto:apache@8080.service" target="_blank" rel="noopener">apache@8080.service</a> 的单元文件，如果没有找到，而文件名中包含 @ 字符，它就会尝试去掉后缀参数匹配模板文件。对于 <a href="mailto:apache@8080.service" target="_blank" rel="noopener">apache@8080.service</a>，Systemd 会找到 apache@.service 模板文件，并通过这个模板文件将服务实例化。</p><h1 id="3-Target"><a href="#3-Target" class="headerlink" title="3. Target"></a>3. Target</h1><p>在传统的 SysV-init 启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。</p><h3 id="3-1-target-vs-sysv-init"><a href="#3-1-target-vs-sysv-init" class="headerlink" title="3.1 target vs sysv-init"></a>3.1 target vs sysv-init</h3><ul><li>默认的 RunLevel（在 /etc/inittab 文件设置）现在被默认的 Target 取代，位置是 /etc/systemd/system/default.target，通常符号链接到graphical.target（图形界面）或者multi-user.target（多用户命令行）。</li><li>启动脚本的位置，以前是 /etc/init.d 目录，符号链接到不同的 RunLevel 目录 （比如 /etc/rc3.d、/etc/rc5.d 等），现在则存放在 /lib/systemd/system 和 /etc/systemd/system 目录。</li><li>配置文件的位置，以前 init 进程的配置文件是 /etc/inittab，各种服务的配置文件存放在 /etc/sysconfig 目录。现在的配置文件主要存放在 /lib/systemd 目录，在 /etc/systemd 目录里面的修改可以覆盖原始设置。</li></ul><p>runlevel是 SysV init 初始化系统中的概念，在Systemd初始化系统中使用的是 Target，他们之间的映射关系是</p><table><thead><tr><th>Runlevel</th><th>Target</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>poweroff.target</td><td>关闭系统</td></tr><tr><td>1</td><td>rescue.target</td><td>维护模式</td></tr><tr><td>2,3,4</td><td>multi-user.target</td><td>多用户，无图形系统（命令行界面）</td></tr><tr><td>5</td><td>graphical.target</td><td>多用户，图形化系统（图形用户界面）</td></tr><tr><td>6</td><td>reboot.target</td><td>重启系统</td></tr></tbody></table><h3 id="3-2-target-vs-unit"><a href="#3-2-target-vs-unit" class="headerlink" title="3.2  target vs unit"></a>3.2 target vs unit</h3><p>如果一个target只包含一个Unit，那么该 target，没有对应的目录，指的就是这个 Unit, 例如 <code>hibernate.target</code>只包含 <code>systemd-hibernate.service</code>一个Unit.</p><p>如果一个target包含多个Unit，那么该target，有对应的 xxx.target.wants 目录，指的是目录里面所有的Unit, 例如<code>multi-user.target</code> 包含位于<code>/etc/systemd/system/multi-user.target.wants</code>目录下的多个 Unit.</p><h3 id="3-3-target-命令"><a href="#3-3-target-命令" class="headerlink" title="3.3 target 命令"></a>3.3 target 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前系统的所有 Target</span></span><br><span class="line">$ systemctl list-unit-files --<span class="built_in">type</span>=target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看一个 Target 包含的所有 Unit</span></span><br><span class="line">$ systemctl list-dependencies multi-user.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看启动时的默认 Target</span></span><br><span class="line">$ systemctl get-default</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置启动时的默认 Target</span></span><br><span class="line">$ sudo systemctl <span class="built_in">set</span>-default multi-user.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换 Target 时，默认不关闭前一个 Target 启动的进程，systemctl isolate 命令改变这种行为，关闭前一个 Target 里面所有不属于后一个 Target 的进程</span></span><br><span class="line">$ sudo systemctl isolate multi-user.target</span><br></pre></td></tr></table></figure><h3 id="3-4-启动过程"><a href="#3-4-启动过程" class="headerlink" title="3.4 启动过程"></a>3.4 启动过程</h3><ol><li>读入 <code>/boot</code> 目录下的内核文件</li><li>内核文件加载完之后，开始执行第一个程序<code>/sbin/init</code> 初始化进程，由 Systemd 初始化系统引导，完成相关的初始化工作</li><li>Systemd 执行<code>default.target</code> ，获知设定的启动 target (查看默认 target: <code>systemctl get-default)</code></li><li>Systemd 执行启动 target 对应的单元文件。根据单元文件中定义的[依赖关系](<a href="https://www.freedesktop.org/software/systemd/man/bootup.html#System" target="_blank" rel="noopener">https://www.freedesktop.org/software/systemd/man/bootup.html#System</a> Manager Bootup)，传递控制权，依次执行其他 target 单元文件，同时启动每个 target 包含的单元</li></ol><h1 id="4-命令"><a href="#4-命令" class="headerlink" title="4. 命令"></a>4. 命令</h1><h3 id="4-1-系统管理命令"><a href="#4-1-系统管理命令" class="headerlink" title="4.1 系统管理命令"></a>4.1 系统管理命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重启系统</span></span><br><span class="line">$ sudo systemctl reboot</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭系统，切断电源</span></span><br><span class="line">$ sudo systemctl poweroff</span><br><span class="line"></span><br><span class="line"><span class="comment"># CPU停止工作</span></span><br><span class="line">$ sudo systemctl halt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂停系统</span></span><br><span class="line">$ sudo systemctl <span class="built_in">suspend</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 让系统进入冬眠状态</span></span><br><span class="line">$ sudo systemctl hibernate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 让系统进入交互式休眠状态</span></span><br><span class="line">$ sudo systemctl hybrid-sleep</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动进入救援状态（单用户状态）</span></span><br><span class="line">$ sudo systemctl rescue</span><br></pre></td></tr></table></figure><h3 id="4-2-查看系统Unit"><a href="#4-2-查看系统Unit" class="headerlink" title="4.2 查看系统Unit"></a>4.2 查看系统Unit</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出正在运行的 Unit</span></span><br><span class="line">$ systemctl list-units</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有Unit，包括没有找到配置文件的或者启动失败的</span></span><br><span class="line">$ systemctl list-units --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有没有运行的 Unit</span></span><br><span class="line">$ systemctl list-units --all --state=inactive</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有加载失败的 Unit</span></span><br><span class="line">$ systemctl list-units --failed</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有正在运行的、类型为 service 的 Unit</span></span><br><span class="line">$ systemctl list-units --<span class="built_in">type</span>=service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Unit 配置文件的内容</span></span><br><span class="line">$ systemctl cat docker.service</span><br></pre></td></tr></table></figure><h3 id="4-3-查看-Unit-的状态"><a href="#4-3-查看-Unit-的状态" class="headerlink" title="4.3 查看 Unit 的状态"></a>4.3 查看 Unit 的状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示系统状态</span></span><br><span class="line">$ systemctl status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示单个 Unit 的状态</span></span><br><span class="line">$ systemctl status bluetooth.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示远程主机的某个 Unit 的状态</span></span><br><span class="line">$ systemctl -H root@rhel7.example.com status httpd.service</span><br></pre></td></tr></table></figure><h3 id="4-4-Unit-的管理"><a href="#4-4-Unit-的管理" class="headerlink" title="4.4 Unit 的管理"></a>4.4 Unit 的管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 立即启动一个服务</span></span><br><span class="line">$ sudo systemctl start apache.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 立即停止一个服务</span></span><br><span class="line">$ sudo systemctl stop apache.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启一个服务</span></span><br><span class="line">$ sudo systemctl restart apache.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 杀死一个服务的所有子进程</span></span><br><span class="line">$ sudo systemctl <span class="built_in">kill</span> apache.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载一个服务的配置文件</span></span><br><span class="line">$ sudo systemctl reload apache.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重载所有修改过的配置文件</span></span><br><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个 Unit 的所有底层参数</span></span><br><span class="line">$ systemctl show httpd.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个 Unit 的指定属性的值</span></span><br><span class="line">$ systemctl show -p CPUShares httpd.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置某个 Unit 的指定属性</span></span><br><span class="line">$ sudo systemctl <span class="built_in">set</span>-property httpd.service CPUShares=500</span><br></pre></td></tr></table></figure><h3 id="4-5-查看-Unit-的依赖关系"><a href="#4-5-查看-Unit-的依赖关系" class="headerlink" title="4.5 查看 Unit 的依赖关系"></a>4.5 查看 Unit 的依赖关系</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出一个 Unit 的所有依赖，默认不会列出 target 类型</span></span><br><span class="line">$ systemctl list-dependencies nginx.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出一个 Unit 的所有依赖，包括 target 类型</span></span><br><span class="line">$ systemctl list-dependencies --all nginx.service</span><br></pre></td></tr></table></figure><h3 id="4-6-服务的生命周期"><a href="#4-6-服务的生命周期" class="headerlink" title="4.6 服务的生命周期"></a>4.6 服务的生命周期</h3><p>当一个新的 Unit 文件被放入 /etc/systemd/system/ 或 /usr/lib/systemd/system/ 目录中时，它是不会被自识识别的。</p><p><strong>服务的激活</strong></p><ul><li>systemctl enable：在 /etc/systemd/system/ 建立服务的符号链接，指向 /usr/lib/systemd/system/ 中</li><li>systemctl start：依次启动定义在 Unit 文件中的 ExecStartPre、ExecStart 和 ExecStartPost 命令</li></ul><p><strong>服务的启动和停止</strong></p><ul><li>systemctl start：依次启动定义在 Unit 文件中的 ExecStartPre、ExecStart 和 ExecStartPost 命令</li><li>systemctl stop：依次停止定义在 Unit 文件中的 ExecStopPre、ExecStop 和 ExecStopPost 命令</li><li>systemctl restart：重启服务</li><li>systemctl kill：立即杀死服务</li></ul><p><strong>服务的开机启动和取消</strong></p><ul><li>systemctl enable：除了激活服务以外，也可以置服务为开机启动</li><li>systemctl disable：取消服务的开机启动</li></ul><p><strong>服务的修改和移除</strong></p><ul><li><p>systemctl daemon-reload：Systemd 会将 Unit 文件的内容写到缓存中，因此当 Unit 文件被更新时，需要告诉 Systemd 重新读取所有的 Unit 文件</p></li><li><p>systemctl reset-failed：移除标记为丢失的 Unit 文件。在删除 Unit 文件后，由于缓存的关系，即使通过 daemon-reload 更新了缓存，在 list-units 中依然会显示标记为 not-found 的 Unit。</p></li></ul><h3 id="4-7-systemctl-与-service-命令的区别"><a href="#4-7-systemctl-与-service-命令的区别" class="headerlink" title="4.7 systemctl 与 service 命令的区别"></a>4.7 systemctl 与 service 命令的区别</h3><ol><li>systemctl 融合了 service 和 chkconfig 的功能</li><li>在 Ubuntu18.04 中没有自带 chkconfig 命令；service 命令实际上重定向到 systemctl 命令</li></ol><table><thead><tr><th>动作</th><th>SysV Init 指令</th><th>Systemd 指令</th></tr></thead><tbody><tr><td>启动某服务</td><td>service httpd start</td><td>systemctl start httpd</td></tr><tr><td>停止某服务</td><td>service httpd stop</td><td>systemctl stop httpd</td></tr><tr><td>重启某服务</td><td>service httpd restart</td><td>systemctl restart httpd</td></tr><tr><td>检查服务状态</td><td>service httpd status</td><td>systemctl status httpd</td></tr><tr><td>删除某服务</td><td>chkconfig –del httpd</td><td>停掉应用，删除其配置文件</td></tr><tr><td>使服务开机自启动</td><td>chkconfig –level 5 httpd on</td><td>systemctl enable httpd</td></tr><tr><td>使服务开机不自启动</td><td>chkconfig –level 5 httpd off</td><td>systemctl disable httpd</td></tr><tr><td>查询服务是否开机自启</td><td>chkconfig –list | grep httpd</td><td>systemctl is-enabled httpd</td></tr><tr><td>加入自定义服务</td><td>chkconfig –add test</td><td>systemctl load test</td></tr><tr><td>显示所有已启动的服务</td><td>chkconfig –list</td><td>systemctl list-unit-files | grep enabled</td></tr></tbody></table><h1 id="5-system-工具集"><a href="#5-system-工具集" class="headerlink" title="5. system 工具集"></a>5. system 工具集</h1><ul><li>systemctl：用于检查和控制各种系统服务和资源的状态</li><li>bootctl：用于查看和管理系统启动分区</li><li>hostnamectl：用于查看和修改系统的主机名和主机信息</li><li>journalctl：用于查看系统日志和各类应用服务日志</li><li>localectl：用于查看和管理系统的地区信息</li><li>loginctl：用于管理系统已登录用户和 Session 的信息</li><li>machinectl：用于操作 Systemd 容器</li><li>timedatectl：用于查看和管理系统的时间和时区信息</li><li>systemd-analyze 显示此次系统启动时运行每个服务所消耗的时间，可以用于分析系统启动过程中的性能瓶颈</li><li>systemd-ask-password：辅助性工具，用星号屏蔽用户的任意输入，然后返回实际输入的内容</li><li>systemd-cat：用于将其他命令的输出重定向到系统日志</li><li>systemd-cgls：递归地显示指定 CGroup 的继承链</li><li>systemd-cgtop：显示系统当前最耗资源的 CGroup 单元</li><li>systemd-escape：辅助性工具，用于去除指定字符串中不能作为 Unit 文件名的字符</li><li>systemd-hwdb：Systemd 的内部工具，用于更新硬件数据库</li><li>systemd-delta：对比当前系统配置与默认系统配置的差异</li><li>systemd-detect-virt：显示主机的虚拟化类型</li><li>systemd-inhibit：用于强制延迟或禁止系统的关闭、睡眠和待机事件</li><li>systemd-machine-id-setup：Systemd 的内部工具，用于给 Systemd 容器生成 ID</li><li>systemd-notify：Systemd 的内部工具，用于通知服务的状态变化</li><li>systemd-nspawn：用于创建 Systemd 容器</li><li>systemd-path：Systemd 的内部工具，用于显示系统上下文中的各种路径配置</li><li>systemd-run：用于将任意指定的命令包装成一个临时的后台服务运行</li><li>systemd-stdio- bridge：Systemd 的内部 工具，用于将程序的标准输入输出重定向到系统总线</li><li>systemd-tmpfiles：Systemd 的内部工具，用于创建和管理临时文件目录</li><li>systemd-tty-ask-password-agent：用于响应后台服务进程发出的输入密码请求</li></ul><h1 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6. 参考资料"></a>6. 参考资料</h1><ul><li><a href="https://www.cnblogs.com/usmile/p/13065594.html" target="_blank" rel="noopener">https://www.cnblogs.com/usmile/p/13065594.html</a></li><li><a href="https://cloud.tencent.com/developer/article/1516125" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1516125</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html</a></li><li><a href="http://www.jinbuguo.com/systemd/systemd.html" target="_blank" rel="noopener">http://www.jinbuguo.com/systemd/systemd.html</a></li></ul></div><div class="reward-container"><div>您打赏的一小步, 钱多了是吗? ( •̀ ω •́ )</div><button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'>打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/images/wechatpay.jpg" alt="levonfly 微信支付"><p>微信支付</p></div><div style="display:inline-block"><img src="/images/alipay.jpg" alt="levonfly 支付宝"><p>支付宝</p></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/linux/" rel="tag"># linux</a> <a href="/tags/systemctl/" rel="tag"># systemctl</a></div><div class="post-nav"><div class="post-nav-item"><a href="/p/84fd7308.html" rel="prev" title="elasticsearch展示网易云听歌记录"><i class="fa fa-chevron-left"></i> elasticsearch展示网易云听歌记录</a></div><div class="post-nav-item"></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-Systemd"><span class="nav-text">1. Systemd</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-前言"><span class="nav-text">1.1 前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-特点"><span class="nav-text">1.2 特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-Unit-和-Target"><span class="nav-text">1.3 Unit 和 Target</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-Systemd-目录"><span class="nav-text">1.4 Systemd 目录</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#2-Unit"><span class="nav-text">2. Unit</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-Unit-File"><span class="nav-text">2.1 Unit File</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-语法"><span class="nav-text">2.2 语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-Unit-段"><span class="nav-text">2.3 Unit 段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-Install段"><span class="nav-text">2.4 Install段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-Service段"><span class="nav-text">2.5 Service段</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5-1-启动类型"><span class="nav-text">2.5.1 启动类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5-2-启动行为"><span class="nav-text">2.5.2 启动行为</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5-3-重启行为"><span class="nav-text">2.5.3 重启行为</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5-4-上下文"><span class="nav-text">2.5.4 上下文</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-占位符"><span class="nav-text">2.6 占位符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-模板"><span class="nav-text">2.7 模板</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-Target"><span class="nav-text">3. Target</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-target-vs-sysv-init"><span class="nav-text">3.1 target vs sysv-init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-target-vs-unit"><span class="nav-text">3.2 target vs unit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-target-命令"><span class="nav-text">3.3 target 命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-启动过程"><span class="nav-text">3.4 启动过程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-命令"><span class="nav-text">4. 命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-系统管理命令"><span class="nav-text">4.1 系统管理命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-查看系统Unit"><span class="nav-text">4.2 查看系统Unit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-查看-Unit-的状态"><span class="nav-text">4.3 查看 Unit 的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-Unit-的管理"><span class="nav-text">4.4 Unit 的管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-查看-Unit-的依赖关系"><span class="nav-text">4.5 查看 Unit 的依赖关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-服务的生命周期"><span class="nav-text">4.6 服务的生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-systemctl-与-service-命令的区别"><span class="nav-text">4.7 systemctl 与 service 命令的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-system-工具集"><span class="nav-text">5. system 工具集</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-参考资料"><span class="nav-text">6. 参考资料</span></a></li></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="levonfly" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">levonfly</p><div class="site-description" itemprop="description">Keep it simple, stupid.</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">187</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">44</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">108</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/unix2dos" title="GitHub → https://github.com/unix2dos" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:levonfly@gmail.com" title="E-Mail → mailto:levonfly@gmail.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a> </span><span class="links-of-author-item"><a href="https://twitter.com/levonfly" title="Twitter → https://twitter.com/levonfly" rel="noopener" target="_blank"><i class="twitter fa-fw"></i>Twitter</a> </span><span class="links-of-author-item"><a href="https://weibo.com/l6241425" title="Weibo → https://weibo.com/l6241425" rel="noopener" target="_blank"><i class="weibo fa-fw"></i>Weibo</a> </span><span class="links-of-author-item"><a href="https://stackoverflow.com/users/7062454" title="Stack → https://stackoverflow.com/users/7062454" rel="noopener" target="_blank"><i class="stack-overflow fa-fw"></i>Stack</a> </span><span class="links-of-author-item"><a href="https://blog.liuvv.com" title="Blog → https://blog.liuvv.com" rel="noopener" target="_blank"><i class="blog fa-fw"></i>Blog</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn" rel="noopener" target="_blank">京ICP备20000727号 </a><img src="/images/beian.png" style="display:inline-block"><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11010502039978" rel="noopener" target="_blank">京公网安备11010502039978号</a></div><div class="copyright">&copy; <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">levonfly</span></div><div style="display:none"><script src="//s95.cnzz.com/z_stat.php?id=1279659588&web_id=1279659588"></script></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>!function(){var e,t,o,n,r,a=document.getElementsByTagName("link");if(0<a.length)for(i=0;i<a.length;i++)"canonical"==a[i].rel.toLowerCase()&&a[i].href&&(e=a[i].href);t=e?e.split(":")[0]:window.location.protocol.split(":")[0],e=e||window.location.href,window,n=e,r=document.referrer,/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(n)||(o="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif",r?(o+="?r="+encodeURIComponent(document.referrer),n&&(o+="&l="+n)):n&&(o+="?l="+n),(new Image).src=o)}()</script><script src="/js/local-search.js"></script><script>NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'Y4ry1QHkYxVXKLQBrx6LJXld-gzGzoHsz',
      appKey     : 'TXITOypSvI7JO61NI8EG5exk',
      placeholder: "留下您的小脚丫吧~",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});</script></body></html>