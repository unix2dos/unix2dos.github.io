# 1. 基础概念



### 1.1 同步



同步

调用端会一直等待服务端响应，直到返回结果。

异步

调用端发起调用之后不会立刻返回，不会等待服务端响应。服务端通过通知机制或者回调函数来通知客户端。

阻塞

服务端返回结果之前，客户端线程会被挂起，此时线程不可被CPU调度，线程暂停运行。

非阻塞

在服务端返回前，函数不会阻塞调用端线程，而会立刻返回。

同步异步的主要区别在于：服务端在拷贝数据时是否阻塞调用端线程；

阻塞和非阻塞的主要区别在于：调用端线程在调用函数后是否立刻返回。

\2. 用户态和核心态

Linux系统中分为核心态(Kernel model)和用户态(User model)，CPU会在两个model之间切换。

用户态和核心态的切换

用户态切换到核心态有三种方式： 

a.系统调用

这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。 

b.异常

当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。

 c.外围设备的中断

当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。

**进程切换**

为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：

保存处理机上下文，包括程序计数器和其他寄存器。

更新PCB信息。

把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。

选择另一个进程执行，并更新其PCB。

更新内存管理的数据结构。

恢复处理机上下文。

进程阻塞

正在执行的进程由于一些事情发生，如请求资源失败、等待某种操作完成、新数据尚未达到或者没有新工作做等，由系统自动执行阻塞原语，使进程状态变为阻塞状态。

因此，进程阻塞是进程自身的一种主动行为，只有处于运行中的进程才可以将自身转化为阻塞状态。当进程被阻塞，它是不占用CPU资源的。

文件描述符(fd)

FD用于描述指向文件的引用的抽象化概念。文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。



# Linux下的五种I/O模型  apue

\1. 阻塞io 

最傻, 不能忍

\2. 非阻塞IO模型

循环调用, ok了拷贝中需要等待

通过进程反复调用IO函数，在数据从内核拷贝到用户空间过程中，进程是阻塞的。

\3. IO复用模型

 ok了通知,   拷贝中需要等待

\5.  组合使用

\6. 多路io复用

 

# 7  NIO

# 8 NIO和多路io复用

 

# 10. 参考资料

自己的io链接

https://juejin.im/post/6844903782094995470