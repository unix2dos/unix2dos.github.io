# 1. 基础概念



### 1.1 同步



同步

调用端会一直等待服务端响应，直到返回结果。

异步

调用端发起调用之后不会立刻返回，不会等待服务端响应。服务端通过通知机制或者回调函数来通知客户端。

阻塞

服务端返回结果之前，客户端线程会被挂起，此时线程不可被CPU调度，线程暂停运行。

非阻塞

在服务端返回前，函数不会阻塞调用端线程，而会立刻返回。

同步异步的主要区别在于：服务端在拷贝数据时是否阻塞调用端线程；

阻塞和非阻塞的主要区别在于：调用端线程在调用函数后是否立刻返回。



1.2  怎样理解阻塞非阻塞与同步异步的区别



还是不同层次的问题……
一个网络包从应用程序A发到另一台电脑上的应用程序B，需要经历：

1. 从A的业务代码到A的软件框架
2. 从A的软件框架到计算机的操作系统内核
3. 从A所在计算机的内核到网卡
4. 从网卡经过网线发到交换机等设备，层层转发，到达B所在计算机的网卡
5. 从B所在计算机的网卡到B所在计算机的内核
6. 从B所在计算机的内核到B的程序的用户空间
7. 从B的软件框架到B的业务代码





这个层级关系就像是过程调用一样，前一级调用后一级的功能，后一级返回一个结果给前一级（比如：成功，或者失败）。只有在单独一级的调用上，可以说同步还是异步的问题。

所谓同步，是指调用协议中结果在调用完成时返回，这样调用的过程中参与双方都处于一个状态同步的过程。

而异步，是指调用方发出请求就立即返回，请求甚至可能还没到达接收方，比如说放到了某个缓冲区中，等待对方取走或者第三方转交；而结果，则通过接收方主动推送，或调用方轮询来得到。









从这个定义中，我们看，首先1和7，这取决于软件框架的设计，如果软件框架可以beginXXX，然后立即返回，这就是一种异步调用，再比如javascript当中的异步HTTP调用，传入参数时提供一个回调函数，回调函数在完成时调用，再比如协程模型，调用接口后马上切换到其他协程继续执行，在完成时由框架切换回到协程中，这都是典型的异步接口设计。





而2和6，其他答主已经说得很好了，其实都需要调用方自己把数据在内核和用户空间里搬来搬去，其实都是同步接口，除非是IOCP这样的专门的异步传输接口，所以这一级其实是同步的，阻塞与非阻塞的区别其实是影响调用接口的结果（在特定条件下是否提前返回结果），而不是调用方式。

3和5，内核一般通过缓冲区，使用DMA来传输数据，所以这一步又是异步的。

4，以太网是个同步时序逻辑，随信号传输时钟，必须两边设备同时就绪了才能开始传输数据，这又是同步的。



总结来说，讨论究竟是异步还是同步，一定要严格说明说的是哪一部分。其他答主说非阻塞是同步而不是异步，这毫无疑问是正确的，然而说某个框架是异步IO的框架，这也是正确的，因为说的其实是框架提供给业务代码的接口是异步的，不管是回调还是协程，比如说我们可以说某个库是异步的HTTPClient，并没有什么问题，因为说的是给业务代码的接口。由于通常异步的框架都需要在2中使用非阻塞的接口，的确会有很多人把非阻塞和异步混为一谈。



---



epoll技术属于IO复用，IO复用属于同步IO，所以epoll属于同步IO，这应该是没毛病的。

现在我用了一个框架，比如twisted，里面的reactor模式的实现是基于epoll或者poll的，在IO的范畴应该是属于同步IO，但是网上几乎所有的文章都说twisted是异步的。

我的问题是，异步与异步IO是不是一个东西？有没有可能异步可以由同步IO(epoll或poll)实现？望大神解答





---



从Linux接口的角度说，阻塞和非阻塞都是同步。

















\2. 用户态和核心态

Linux系统中分为核心态(Kernel model)和用户态(User model)，CPU会在两个model之间切换。

用户态和核心态的切换

用户态切换到核心态有三种方式： 

a.系统调用

这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。 

b.异常

当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。

 c.外围设备的中断

当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。

**进程切换**

为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：

保存处理机上下文，包括程序计数器和其他寄存器。

更新PCB信息。

把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。

选择另一个进程执行，并更新其PCB。

更新内存管理的数据结构。

恢复处理机上下文。

进程阻塞

正在执行的进程由于一些事情发生，如请求资源失败、等待某种操作完成、新数据尚未达到或者没有新工作做等，由系统自动执行阻塞原语，使进程状态变为阻塞状态。

因此，进程阻塞是进程自身的一种主动行为，只有处于运行中的进程才可以将自身转化为阻塞状态。当进程被阻塞，它是不占用CPU资源的。

文件描述符(fd)

FD用于描述指向文件的引用的抽象化概念。文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。



# Linux下的五种I/O模型  apue

\1. 阻塞io 

最傻, 不能忍

\2. 非阻塞IO模型

循环调用, ok了拷贝中需要等待

通过进程反复调用IO函数，在数据从内核拷贝到用户空间过程中，进程是阻塞的。

\3. IO复用模型

 ok了通知,   拷贝中需要等待

\5.  组合使用

\6. 多路io复用





阻塞IO模型，非阻塞IO模型，IO复用模型，信号驱动IO模型都是同步IO。

epoll也是IO复用模型，应该是同步IO。

 

# 7  NIO

# 8. Aio

# 8 NIO和多路io复用

java nio的io模型是同步非阻塞，这里的同步异步指的是真正io操作（数据内核态用户态的拷贝）是否需要进程参与。

而说java nio提供了异步处理，这个异步应该是指编程模型上的异步。基于reactor模式的事件驱动，事件处理器的注册和处理器的执行是异步的。

 

# 10. 参考资料

自己的io链接

https://juejin.im/post/6844903782094995470

 https://www.zhihu.com/question/19732473/answer/117012135

https://blog.csdn.net/Jailman/article/details/78498193

https://www.cnblogs.com/dolphin0520/p/3916526.html

https://colobu.com/2014/11/13/java-aio-introduction/