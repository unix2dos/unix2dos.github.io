时间序列数据库 Time Series Database (TSDB)

1.1 时序数据特点
时序数据有如下几个特点：
基本上是插入操作较多且无更新的需求
数据带有时间属性，且数据量随着时间递增
插入数据多，每秒钟插入需要可到达千万甚至是上亿的数据量
查询、聚合等操作主要针对近期插入的数据
时序数据能够还原数据的变化状态
可以通过分析过去时序数据的变化、检测现在的变化，以达到预测未来如何变化的目的
时序数据使用需求：
能够按照指标筛选数据
能够按照区间、时间范围、统计信息聚合展示数据






 特点：

写入特点：

写多读少（这与其数据特性相关，例如报表，实时监控，通常只会关心几个特定的关键指标或者在特定的场景下才会去读数据）
写入平稳、持续、高并发高吞吐（时序数据的产生通常是以一个固定的时间频率产生，不会受其他因素的制约，其数据生成的速度是相对比较平稳的。）
实时写入最近生成的数据，无 update。（跟时间数据特性有关，数据是随着时间推进的，每次数据都是新数据，故不存在旧数据的更新，但不排除人为数据的更正）
查询特点：

按时间范围读取：通常来说不会去关心某个特定点的数据，而是一段时间的数据。
最近的数据被读取的概率高
历史数据粗粒度查询的概率高（粗粒度和细粒度的区别主要是出于重用的目的，像类的设计，为尽可能重用，所以采用细粒度的设计模式，将一个复杂的类 (粗粒度) 拆分成高度重用的职责清晰的类 (细粒度). 对于数据库的设计，原责：尽量减少表的数量与表与表之间的连接，能够设计成一个表的情况就不需要细分，所以可考虑使用粗粒度的设计方式.）
多精度查询
多维度分析
存储特点：

数据量大（比如 A 节点的一个监控项上传周期是 1s，该节点的这个监控项每天会产生 86400 个数据点，若有 1 万个监控项，则一天产生 86400 万条数据。实际应用会是 TB 甚至 PB 级）
冷热分明（越是历史的数据，被查询和分析的概率越低）
具有时效性（数据通常会有一个保存周期，超过这个保存周期的数据可以认为是失效的，可以被回收。一方面是因为越是历史的数据，可利用的价值越低；另一方面是为了节省存储成本，低价值的数据可以被清理）
多精度数据存储












不同的数据库针对的应用场景有不同的偏重。TSDB（ time series database ）时序数据库是专门以时间维度进行设计和优化的。
TSDB 通常具有以下的特点：
时间是不可或缺的绝对主角（就像 MySQL 中的主键一样），数据按照时间顺序组织管理
高并发高吞吐量的数据写入
数据的更新很少发生
过期的数据可以批量删除



时间序列数据就是历史烙印，具有不变性,、唯一性、时间排序性

时序数据是基于时间的一系列的数据。在有时间的坐标中将这些数据点连成线，往过去看可以做成多纬度报表，揭示其趋势性、规律性、异常性；往未来看可以做大数据分析，机器学习，实现预测和预警。


时序数据库就是存放时序数据的数据库，并且需要支持时序数据的快速写入、持久化、多纬度的聚合查询等基本功能。


很多人可能认为在传统关系型数据库上加上时间戳一列就能作为时序数据库。数据量少的时候确实也没问题，但少量数据是展现的纬度有限，细节少，可置信低，更加不能用来做大数据分析。很明显时序数据库是为了解决海量数据场景而设计的。







数据写入的特点
写入平稳、持续、高并发高吞吐：时序数据的写入是比较平稳的，这点与应用数据不同，应用数据通常与应用的访问量成正比，而应用的访问量通常存在波峰波谷。时序数据的产生通常是以一个固定的时间频率产生，不会受其他因素的制约，其数据生成的速度是相对比较平稳的。
写多读少：时序数据上95%-99%的操作都是写操作，是典型的写多读少的数据。这与其数据特性相关，例如监控数据，你的监控项可能很多，但是你真正去读的可能比较少，通常只会关心几个特定的关键指标或者在特定的场景下才会去读数据。
实时写入最近生成的数据，无更新：时序数据的写入是实时的，且每次写入都是最近生成的数据，这与其数据生成的特点相关，因为其数据生成是随着时间推进的，而新生成的数据会实时的进行写入。数据写入无更新，在时间这个维度上，随着时间的推进，每次数据都是新数据，不会存在旧数据的更新，不过不排除人为的对数据做订正。



数据查询和分析的特点
按时间范围读取：通常来说，你不会去关心某个特定点的数据，而是一段时间的数据。
最近的数据被读取的概率高
历史数据粗粒度查询的概率高
多种精度查询
多维度分析


数据存储的特点
数据量大：拿监控数据来举例，如果我们采集的监控数据的时间间隔是1s，那一个监控项每天会产生86400个数据点，若有10000个监控项，则一天就会产生864000000个数据点。在物联网场景下，这个数字会更大。整个数据的规模，是TB甚至是PB级的。
冷热分明：时序数据有非常典型的冷热特征，越是历史的数据，被查询和分析的概率越低。
具有时效性：时序数据具有时效性，数据通常会有一个保存周期，超过这个保存周期的数据可以认为是失效的，可以被回收。一方面是因为越是历史的数据，可利用的价值越低；另一方面是为了节省存储成本，低价值的数据可以被清理。
多精度数据存储：在查询的特点里提到时序数据出于存储成本和查询效率的考虑，会需要一个多精度的查询，同样也需要一个多精度数据的存储。

基本概念
metric: 度量，相当于关系型数据库中的table。
data point: 数据点，相当于关系型数据库中的row。
timestamp：时间戳，代表数据点产生的时间。
field: 度量下的不同字段。比如位置这个度量具有经度和纬度两个field。一般情况下存放的是会随着时间戳的变化而变化的数据。
tag: 标签，或者附加信息。一般存放的是并不随着时间戳变化的属性信息。timestamp加上所有的tags可以认为是table的primary key。

如下图，度量为Wind，每一个数据点都具有一个timestamp，两个field：direction和speed，两个tag：sensor、city。它的第一行和第三行，存放的都是sensor号码为95D8-7913的设备，属性城市是上海。随着时间的变化，风向和风速都发生了改变，风向从23.4变成23.2；而风速从3.4变成了3.3。










数据的存储
数据的存储可以分为两个问题，单机上存储和分布式存储。
+ 单机存储
如果只是存储起来，直接写成日志就行。但因为后续还要快速的查询，所以需要考虑存储的结构。
传统数据库存储采用的都是B tree，这是由于其在查询和顺序插入时有利于减少寻道次数的组织形式。我们知道磁盘寻道时间是非常慢的，一般在10ms左右。磁盘的随机读写慢就慢在寻道上面。对于随机写入B tree会消耗大量的时间在磁盘寻道上，导致速度很慢。我们知道SSD具有更快的寻道时间，但并没有从根本上解决这个问题。
对于90%以上场景都是写入的时序数据库，B tree很明显是不合适的。



业界主流都是采用LSM tree替换B tree。
LSM tree包括内存里的数据结构和磁盘上的文件两部分。分别对应Hbase里的MemStore和HLog；对应Cassandra里的MemTable和sstable。

LSM tree操作流程如下：
1.数据写入和更新时首先写入位于内存里的数据结构。为了避免数据丢失也会先写到WAL文件中。
2.内存里的数据结构会定时或者达到固定大小会刷到磁盘。这些磁盘上的文件不会被修改。
3.随着磁盘上积累的文件越来越多，会定时的进行合并操作，消除冗余数据，减少文件数量。









可以看到LSM tree核心思想就是通过内存写和后续磁盘的顺序写入获得更高的写入性能，避免了随机写入。但同时也牺牲了读取性能，因为同一个key的值可能存在于多个HFile中。

\+ 分布式存储

时序数据库面向的是海量数据的写入存储读取，单机是无法解决问题的。所以需要采用多机存储，也就是分布式存储。

分布式存储首先要考虑的是如何将数据分布到多台机器上面，也就是 分片（sharding）问题。下面我们就时序数据库分片问题展开介绍。分片问题由分片方法的选择和分片的设计组成。

分片方法

时序数据库的分片方法和其他分布式系统是相通的。

哈希分片：这种方法实现简单，均衡性较好，但是集群不易扩展。

一致性哈希：这种方案均衡性好，集群扩展容易，只是实现复杂。代表有Amazon的DynamoDB和开源的Cassandra。

范围划分：通常配合全局有序，复杂度在于合并和分裂。代表有Hbase。

分片设计

分片设计简单来说就是以什么做分片，这是非常有技巧的，会直接影响写入读取的性能。

结合时序数据库的特点，根据metric+tags分片是比较好的一种方式，因为往往会按照一个时间范围查询，这样相同metric和tags的数据会分配到一台机器上连续存放，顺序的磁盘读取是很快的。再结合上面讲到的单机存储内容，可以做到快速查询。

进一步我们考虑时序数据时间范围很长的情况，需要根据时间范围再将分成几段，分别存储到不同的机器上，这样对于大范围时序数据就可以支持并发查询，优化查询速度。

如下图，第一行和第三行都是同样的tag（sensor=95D8-7913;city=上海），所以分配到同样的分片，而第五行虽然也是同样的tag，但是根据时间范围再分段，被分到了不同的分片。第二、四、六行属于同样的tag（sensor=F3CC-20F3;city=北京）也是一样的道理。







2. InfluxDB


InfluxDB 就是一款非常优秀的时序数据库，高居 DB-Engines TSDB rank 榜首。
InfluxDB 分为免费的社区开源版本，以及需要收费的闭源商业版本，目前只有商业版本支持集群。
InfluxDB 的底层数据结构从 LSM 树到 B+ 树折腾了一通，最后自创了一个 TSM 树（ Time-Structured Merge Tree ），这也是它性能高且资源占用少的重要原因。
InfluxDB 由 go 语言编写而成，没有额外的依赖，它的查询语言 InfluxQL 与 SQL 极其相似，使用特别简单。








2、常见的时序数据库有哪些以及特点是什么？

1999/07/16 RRDTool First release
2009/12/30 Graphite 0.9.5
2011/12/23 OpenTSDB 1.0.0
2013/05/24 KairosDB 1.0.0-beta
2013/10/24 InfluxDB 0.0.1
2014/08/25 Heroic 0.3.0
2017/03/27 TimescaleDB 0.0.1-beta
RRDTool 是最早的时间序列数据库，它自带画图功能，现在大部分时间序列数据库都使用 Grafana 来画图。

Graphite 是用 Python 写的 RRD 数据库，它的存储引擎 Whisper 也是 Python 写的， 它画图和聚合能力都强了很多，但是很难水平扩展。

OpenTSDB 使用 HBase 解决了水平扩展的问题

KairosDB 最初是基于 OpenTSDB 修改的，但是作者认为兼容 HBase 导致他们不能使用很多 Cassandra 独有的特性， 于是就抛弃了 HBase 仅支持 Cassandra。

新发布的 OpenTSDB 中也加入了对 Cassandra 的支持。故事还没完，Spotify 的人本来想使用 KairosDB，但是觉得项目发展方向不对以及性能太差，就自己撸了一个 Heroic。

InfluxDB 早期是完全开源的，后来为了维持公司运营，闭源了集群版本。增加专门的时间序列数据库单元。

3、InfluxDB

概念：

InfluxDB 是一个用于存储和分析时间序列数据的开源数据库。   

存储引擎:

Time Structured Merge Tree (TSM) 和 Log Structured Merge Tree (LSM) 

写入的时候，数据先写入到内存里，之后批量写入到硬盘。
读的时候，同时读内存和硬盘然后合并结果。
删除的时候，写入一个删除标记，被标记的数据在读取时不会被返回。
后台会把小的块合并成大的块，此时被标记删除的数据才真正被删除
相对于普通数据，有规律的时间序列数据在合并的过程中可以极大的提高压缩比。
特性：

内置 HTTP 接口，使用方便
数据可以打标记，这样查询可以很灵活
类 SQL 的查询语句
安装管理很简单，并且读写数据很高效
能够实时查询，数据在写入时被索引后就能够被立即查出



![https://note.youdao.com/yws/public/resource/efbee018f5183e05abc995e4753e0a2a/xmlnote/0C11F08C300C445EB210C8E0635D3BA2/47826](%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E4%BB%8B/47826.png)



![https://note.youdao.com/yws/public/resource/efbee018f5183e05abc995e4753e0a2a/xmlnote/E5F366E7FB7E49E39960803CFA9F437B/47794](%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E4%BB%8B/47794.png)



![https://note.youdao.com/yws/public/resource/efbee018f5183e05abc995e4753e0a2a/xmlnote/1E71AC41F5DC477BA21D901AA934DA8E/47816](%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E4%BB%8B/47816.png)

https://db-engines.com/en/ranking/time+series+dbms 排名



![https://note.youdao.com/yws/public/resource/efbee018f5183e05abc995e4753e0a2a/xmlnote/1F479CC6528D49ECB2A99CF3B77B6D8A/47822](%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E4%BB%8B/47822.png)

https://www.jianshu.com/p/31afb8492eff
https://cloud.tencent.com/developer/article/1115643
https://learnku.com/articles/37149