---
title: 'https协议'
tags:
  - http
  - linux
categories:
  - 3-计算机系统
  - https
date: 2019-07-18 19:08:00
---


# 1. https 协议

HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：可以理解为HTTP+SSL/TLS， 即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL，用于安全的 HTTP 数据传输。

<!-- more -->

> SSL历史和版本

1994年，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。

1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。

1996年，SSL 3.0版问世，得到大规模应用。

1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS 1.0版。

2006年和2008年，TLS进行了两次升级，分别为TLS 1.1版和TLS 1.2版。最新的变动是2011年TLS 1.2的修订版。


目前，应用最广泛的是TLS 1.0，接下来是SSL 3.0。但是，主流浏览器都已经实现了TLS 1.2的支持。

---
TLS 1.0通常被标示为SSL 3.1

TLS 1.1为SSL 3.2，

TLS 1.2为SSL 3.3。




# 2. 非对称加密和数字证书

+ HTTPS的数据传输是加密的。实际使用中，HTTPS利用的是对称与非对称加密算法结合的方式。

+ 对称加密，就是通信双方使用一个密钥，该密钥既用于数据加密（发送方），也用于数据解密（接收方）。

+ 非对称加密，使用两个密钥。发送方使用公钥（公开密钥）对数据进行加密，数据接收方使用私钥对数据进行解密。

+ 实际操作中，单纯使用对称加密或单纯使用非对称加密都会存在一些问题，比如对称加密的密钥管理复杂；非对称加密的处理性能低、资源占用高等，因 此HTTPS结合了这两种方式。

+ HTTPS服务端在连接建立过程（ssl shaking握手协议）中，会将自身的公钥发送给客户端。客户端拿到公钥后，与服务端协商数据传输通道的对称加密密钥-对话密钥，随后的这个协商过程则 是基于非对称加密的（因为这时客户端已经拿到了公钥，而服务端有私钥）。

+ 一旦双方协商出对话密钥，则后续的数据通讯就会一直使用基于该对话密钥的对称加密算法了。(对称加密会加快速度)



上述过程有一个问题，那就是双方握手过程中，如何保障HTTPS服务端发送给客户端的公钥信息没有被篡改呢？实际应用中，HTTPS并非直接传输公钥信息，而是使用携带公钥信息的数字证书来保证公钥的安全性和完整性。

数字证书，又称互联网上的"身份证"，用于唯一标识一个组织或一个服务器的，这就好比我们日常生活中使用的"居民身份证"，用于唯一标识一个人。

服务端将数字证书传输给客户端，客户端如何校验这个证书的真伪呢？我们知道居民身份证是由国家统一制作和颁发的，个人向户口所在地公安机关申请，国家颁发的身份证才具有法律效力，任何地方这个身份证都是有效和可被接纳的。

网站的证书也是同样的道理。一般来说数字证书从受信的权威证书授权机构 (Certification Authority，证书授权机构)买来的（免费的很少）。一般浏览器在出厂时就内置了诸多知名CA（如Verisign、GoDaddy、美国国防部、 CNNIC等）的数字证书校验方法，只要是这些CA机构颁发的证书，浏览器都能校验。

对于CA未知的证书，浏览器则会报错。主流浏览器都有证书管理功能，但鉴于这些功能比较高级，一般用户是不用去关心的。



# 3. tls交互四次握手

TLS 握手的关键在于利用通信双方生成的随机字符串和服务端的公钥生成一个双方经过协商后的密钥，通信的双方可以使用这个对称的密钥加密消息防止中间人的监听和攻击，保证通信的安全。后续通过对称密钥传递信息。

<!-- more -->

①  客户端向服务端发送 Client Hello 消息

+ 协议版本（ eg：TLS 1.0）

+ 加密算法（eg：RSA）

+ 压缩算法

+ 客户端生成的随机数(稍后用于生成对话密钥)



② 服务端向客户端发送 Server Hello 消息

+ 协议版本，加密算法确认
+ 会话 ID
+ 服务器数字证书
+ 服务器公钥
+ 服务端生成的随机数(稍后用于生成对话密钥)



③ 客户端验证 服务器证书 和 协商密钥

+ 连接服务器的 CA 验证服务端的证书
+ 向服务端发送 Client Key Exchange , 用服务器公钥加密。
+ 向服务端发送 Finished 消息，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。



④ 向客户端发送 Finished 消息

+ 计算生成本次会话所用的会话密钥
+ 向客户端发送 Client Key Exchange, 表示随后的信息都将用双方商定的加密方法和密钥发送。
+ 向客户端发送 Finished 消息，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。



### 3.1 形象化比喻

我们假设A与B通信，A是SSL客户端，B是SSL服务器端。

加密后的消息放在方括号[]里，以突出明文消息的区别。双方的处理动作的说明用圆括号（）括起。



①A：我想和你安全的通话，我这里的对称加密算法有DES,RC5,密钥交换算法有RSA和DH，摘要算法有MD5和SHA。

②B：我们用DES－RSA－SHA这对组合好了。这是我的证书，里面有我的名字和公钥，你拿去验证一下我的身份。

③A：（通过CA的证书验证了B的证书的真实性，如果其中一项有误，发出警告并断开连接，这一步保证了B的公钥的真实性）

我生成了一份秘密消息，并用你的公钥加密了，给你（把ClientKeyExchange发给B）注意，下面我就要用加密的办法给你发消息了！

[我说完了]

④B：（用自己的私钥将ClientKeyExchange中的秘密消息解密出来，然后将秘密消息进行处理，生成加密密钥）

注意，我也要开始用加密的办法给你发消息了！

[我说完了]

---

A: [我的秘密是...]

B: [其它人不会听到的...]



### 3.2 证书的数字签名（Digital Signature）

使用散列和非对称加密验证文档的真实性。先为要签名的信息生成一个Hash字串，Hash1，然后用你的私钥加密得到Encrypted(Hash1)，这就是你对这个文档的数字签名。

当别人需要验证某个文档是否是你签名的时候，只需要用你的公钥解密你的签名得到Hash1，并和该文档计算出来的Hash2对比，查看是否一致。如果一致则说明你确实对该文档签过名，否则就是没有。



# 4. 参考资料

+ https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html

+ https://draveness.me/whys-the-design-https-latency/