---
title: tls交互四次握手
tags:
  - http
categories:
  - 3-计算机系统
  - Http
abbrlink: 45348d89
date: 2020-01-07 00:00:00
---



# 1. tls交互四次握手

TLS 握手的关键在于利用通信双方生成的随机字符串和服务端的公钥生成一个双方经过协商后的密钥，通信的双方可以使用这个对称的密钥加密消息防止中间人的监听和攻击，保证通信的安全。后续通过对称密钥传递信息。

<!-- more -->

①  客户端向服务端发送 Client Hello 消息

+ 协议版本（ eg：TLS 1.0）

+ 加密算法（eg：RSA）

+ 压缩算法

+ 客户端生成的随机数(稍后用于生成对话密钥)



② 服务端向客户端发送 Server Hello 消息

+ 协议版本，加密算法确认
+ 会话 ID
+ 服务器数字证书
+ 服务器公钥
+ 服务端生成的随机数(稍后用于生成对话密钥)



③ 客户端验证 服务器证书 和 协商密钥

+ 连接服务器的 CA 验证服务端的证书
+ 向服务端发送 Client Key Exchange , 用服务器公钥加密。
+ 向服务端发送 Finished 消息，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。



④ 向客户端发送 Finished 消息

+ 计算生成本次会话所用的会话密钥
+ 向客户端发送 Client Key Exchange, 表示随后的信息都将用双方商定的加密方法和密钥发送。
+ 向客户端发送 Finished 消息，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。



# 2. 形象化比喻

我们假设A与B通信，A是SSL客户端，B是SSL服务器端。

加密后的消息放在方括号[]里，以突出明文消息的区别。双方的处理动作的说明用圆括号（）括起。



①A：我想和你安全的通话，我这里的对称加密算法有DES,RC5,密钥交换算法有RSA和DH，摘要算法有MD5和SHA。

②B：我们用DES－RSA－SHA这对组合好了。这是我的证书，里面有我的名字和公钥，你拿去验证一下我的身份。

③A：（通过CA的证书验证了B的证书的真实性，如果其中一项有误，发出警告并断开连接，这一步保证了B的公钥的真实性）

我生成了一份秘密消息，并用你的公钥加密了，给你（把ClientKeyExchange发给B）注意，下面我就要用加密的办法给你发消息了！

[我说完了]

④B：（用自己的私钥将ClientKeyExchange中的秘密消息解密出来，然后将秘密消息进行处理，生成加密密钥）

注意，我也要开始用加密的办法给你发消息了！

[我说完了]

---

A: [我的秘密是...]

B: [其它人不会听到的...]



# 3. 问题总结

### 3.1 证书的数字签名（Digital Signature）

使用散列和非对称加密验证文档的真实性。先为要签名的信息生成一个Hash字串，Hash1，然后用你的私钥加密得到Encrypted(Hash1)，这就是你对这个文档的数字签名。

当别人需要验证某个文档是否是你签名的时候，只需要用你的公钥解密你的签名得到Hash1，并和该文档计算出来的Hash2对比，查看是否一致。如果一致则说明你确实对该文档签过名，否则就是没有。



# 4. 参考资料

+ https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html

+ https://draveness.me/whys-the-design-https-latency/