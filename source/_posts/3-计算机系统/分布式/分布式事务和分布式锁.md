---
title: 分布式事务和分布式锁
tags:
  - 分布式
categories:
  - 3-计算机系统
  - 分布式
abbrlink: bb1dd10
date: 2019-11-07 00:00:00
---



# 0. 分布式理论

分布式系统的核心就是解决一个问题：不同节点间如何达成共识。

### 0.1 一致性问题

一致性问题就是相互独立的节点之间如何达成一项决议的问题。

分布式系统中，进行数据库事务提交(commit transaction)、Leader选举、序列号生成等都会遇到一致性问题。

<!-- more -->

一致性还具备两个属性

+ 一个是强一致(safety)，它要求所有节点状态一致、共进退；

+ 一个是可用(liveness)，它要求分布式系统24*7无间断对外服务。

FLP定理(FLP impossibility) 否定了同时满足safety 和 liveness 的一致性协议的存在。工程实践上根据具体的业务场景，或保证强一致(safety)，或在节点宕机、网络分化的时候保证可用(liveness)。

所以 CAP 模型, 要么是 CP, 或者AP, CA 不存在。



# 1. 强一致性解决方案

### 1.1 XA两阶段提交(2PC)

2PC(tow phase commit)两阶段提交顾名思义它分成两个阶段，先由一方进行提议(propose)并收集其他节点的反馈(vote)，再根据反馈决定提交(commit)或中止(abort)事务。

在异步环境(asynchronous)并且没有节点宕机(fail-stop)的模型下，2PC可以满足全认同、值合法、可结束，是解决一致性问题的一种协议。

##### 1.1.1 角色

+ 我们将提议的节点称为协调者(coordinator)
+ 其他参与决议节点称为参与者(participants, 或cohorts)

##### 1.1.2 执行过程

+ 第一阶段

  coordinator发起一个提议，分别问询各participant是否接受。participant执行本地事务, 结果给coordinator。

+ 第二阶段

  coordinator根据participant的反馈，下达提交或中止事务，如果participant全部同意则提交，只要有一个participant不同意就中止。

##### 1.1.3 宕机处理

coordinator如果在发起提议后宕机，那么participant将进入阻塞(block)状态、一直等待coordinator回应以完成该次决议。这时需要另一角色把系统从不可结束的状态中带出来，我们把新增的这一角色叫协调者备份(coordinator watchdog)。

coordinator宕机一定时间后，coordinator watchdog接替原coordinator工作，通过问询(query) 各participant的状态，决定阶段2是提交还是中止。

这也要求 coordinator/participant 记录(logging)历史状态，以备coordinator宕机后watchdog对participant查询、coordinator宕机恢复后重新找回状态。

### 1.2 三阶段提交(3PC)

相比2PC，3PC增加了一个准备提交(prepare to commit)阶段。

在2PC中一个participant的状态只有它自己和coordinator知晓，假如coordinator提议后自身宕机，在watchdog启用前一个participant又宕机，其他participant就会进入既不能回滚、又不能强制commit的阻塞状态，直到participant宕机恢复。

##### 1.2.1 执行过程

+ 第一阶段

  cancommit 是否可以执行事务

+ 第二阶段

  precommit 准备提交阶段  执行事务, 不提交, 返回给协调者

+ 第三阶段

  docommit 

##### 1.2.2 宕机处理

+ 阶段1: 

  coordinator或watchdog未收到宕机participant的vote，直接中止事务；

​	宕机的participant恢复后，读取logging发现未发出赞成vote，自行中止该次事务

+ 阶段2: 

  coordinator未收到宕机participant的precommit ACK，但因为之前已经收到了宕机participant的赞成反馈(不然也不会进入到阶段2)，coordinator进行commit；

  宕机的participant恢复后发现收到precommit或已经发出赞成vote，则自行commit该次事务

+ 阶段3: 

  即便coordinator或watchdog未收到宕机participant的commit ACK，也结束该次事务；

  宕机的participant恢复后发现收到commit或者precommit，也将自行commit该次事务

##### 1.2.3 总结

因为有了准备提交(prepare to commit)阶段，3PC的事务处理延时也增加了1个RTT，变为3个RTT(propose+precommit+commit)，但是它防止participant宕机后整个系统进入阻塞态，增强了系统的可用性，对一些现实业务场景是非常值得的。

### 1.3 TCC 补偿机制

业务侵入, 业务的回滚, 有可能数据库不支持事务

+ 第一阶段

  Try, 试试是否可执行

+ 第二阶段

  Confirm, 执行业务, 直接提交, try 成功, confirm 也就成功

+ 第三阶段

  Cancel, 业务出错了, 在回滚, 单独一个方法

  

# 2. 最终一致性解决方案

### 2.1 本地消息表

+ A执行事务成功, 发送到消息队列
+ B从消息队列取出数据, 执行事务
+ B 执行成功或失败, 通知 A, 决定提交还是回滚

### 2.2 MQ 消息队列

RabbitMQ 和 Kafka 不支持事务消息,  RocketMQ 支持

+ A先发送消息到事务队列, 状态为Prepare, 这个消息不会被消费
+ A执行本地事务成功了, 发送Confirm, 把队列改成可消费状态
+ B拿到消息后, 开始执行事务, 发送ACK, 修改队列的状态
+ A看队列的状态决定提交还是回滚

### 2.3 Seata


+ XA 和 AT两阶段提交
XA 事务是数据库的事务
AT 的事务和数据库有了脱离



# 3. 分布式锁

### 3.1 数据库

开销较大

##### 3.1.2 表的主键来实现

+ 同一个主键插入成功获得锁
+ 其他插入主键冲突, 失败
+ 执行成功删除主键, 释放锁

##### 3.1.3 排它锁实现

+ select for update,拿到锁
+ 其他事务阻塞
+ 拿到锁以后, commit 释放锁

### 3.2 redis

1. SETNX + expire 函数解决, 2个函数没有达到原子性

2. SET() 里面有过期时间, 一个函数搞定, 但是其他过期了, 可以释放别人的锁

3. 通过UUID 判断, 只能释放自己的锁

### 3.3 redission

类似上面的原理, 直接用

### 3.4 zookeeper

通过临时和序号的原理, 加上 watch 的原理

+ 创建临时序号节点
+ 获取最小的节点是否时读锁, 如果是读, 那么获得锁
+ 如果不是, 阻塞等待,  每个节点只监听它的上一个节点, 获取通知

### 3.5 consul

类型 redis, 两个函数

+ acquir(key, value) 成功返回 true, 失败返回 false
+ release(key) 删除 key

### 3.6 etcd

续约功能, 防止无法释放

Revision功能, 执行会加一, 用来判断

Watch 功能, 监听 revision 比自己小的

Prefix 功能：获取一个列表

+ 步骤 1

  客户端连接 Etcd，以 /lock/mylock 为前缀创建全局唯一的 key，
  假设第一个客户端对应的 key="/lock/mylock/UUID1"，第二个为 key="/lock/mylock/UUID2"；

  客户端分别为自己的 key 创建租约 - Lease，租约的长度根据业务耗时确定，假设为 15s；


+ 步骤 2

  创建定时任务作为租约的“心跳”
  当一个客户端持有锁期间，其它客户端只能等待，为了避免等待期间租约失效，客户端需创建一个定时任务作为“心跳”进行续约。此外，如果持有锁期间客户端崩溃，心跳停止，key 将因租约到期而被删除，从而锁释放，避免死锁。

+ 步骤 3

  客户端将自己全局唯一的 key 写入 Etcd 进行 put 操作，将步骤 1 中创建的 key 绑定租约写入 Etcd，根据 Etcd 的 Revision 机制，假设两个客户端 put 操作返回的 Revision 分别为 1、2，客户端需记录 Revision 用以接下来判断自己是否获得锁。

+ 步骤 4

  客户端以前缀 /lock/mylock 读取 keyValue 列表（keyValue 中带有 key 对应的 Revision），判断自己 key 的 Revision 是否为当前列表中最小的，如果是则认为获得锁；

  否则监听列表中前一个 Revision 比自己小的 key 的删除事件，一旦监听到删除事件或者因租约失效而删除的事件，则自己获得锁。

+ 步骤 5
  获得锁后，操作共享资源，执行业务代码。
+ 步骤 6 
  完成业务流程后，删除对应的key释放锁。



# 4. 其他补充

### 4.1 zab 和 raft 什么区别

//TODO:

# 5. 参考资料

+ https://www.cnblogs.com/bangerlee/p/6216997.html