---
title: mysql索引介绍
tags:
  - mysql
categories:
  - 1-编程语言
  - sql
abbrlink: '84544518'
date: 2019-06-01 00:00:06
---

# 1. 索引

### 1.1 索引是什么？有什么作用以及优缺点？

- 是一种快速查询表中内容的机制，类似于新华字典的目录
- 运用在表中某个些字段上，但存储时，独立于表之外，有一张专门的索引表

<!-- more -->

### 1.2 什么时候要创建索引

- 表经常进行 SELECT 操作
- 表很大(记录超多)，记录内容分布范围很广
- 列名经常在 WHERE 子句或连接条件中出现

### 1.3 什么时候不要创建索引

- 表经常进行 INSERT/UPDATE/DELETE 操作
- 表很小(记录超少)
- 列名不经常作为连接条件或出现在 WHERE 子句中
- 字段内容重复很多



# 2. 索引分类

### 2.1 从存储结构上来划分

+ Btree 索引（B+tree，B-tree)

- 哈希索引

  哈希索引一般适用于：不需要做排序**、**范围查询的需求。

  - 哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能的影响并不明显。
  - 哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序。
  - 哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。例如，在数据列(A, B)上建立哈希索引，如果查询只有数据列A，则无法使用该索引。
  - 哈希索引只支持等值比较查询，包括=、in()、<=>。不支持任何范围查询，例如where price > 100。
  - 访问哈希索引的数据非常快，除非有很多哈希冲突。
  - 如果哈希冲突很多的话，一些索引维护操作的代价也很高。

- full-index 全文索引

- RTree



### 2.2 从应用层次上来划分

- 普通索引：即一个索引只包含单个列，一个表可以有多个单列索引。
- 唯一索引：索引列的值必须唯一，但允许有空值。
  + 普通唯一索引：单个字段上建立唯一索引，需要此字段所在的列上不能有重复的值，属于二级索引。
  + 复合唯一索引：多个字段上联合建立唯一索引，属于二级索引。
- 复合索引：一个索引包含多个列。



##### 2.2.1 唯一索引和主键索引区别

+ 主键就是唯一索引，但是唯一索引不一定是主键

+ 唯一索引可以为空，但是空值只能有一个，主键不能为空。



### 2.3 从表记录的排列顺序和索引的排列顺序是否一致来划分

- 聚集索引

  表记录的排列顺序和索引的排列顺序一致。(类似拼音查字)

  1. 一个表中只能拥有一个聚集索引。

  2. SQL SERVER默认是在主键上建立聚集索引的。

  3. 聚集索引表记录的排列顺序和索引的排列顺序一致，所以查询效率快，因为只要找到第一个索引值记录，其余的连续性的记录在物理表中也会连续存放，一起就可以查询到。

  4. 缺点是新增比较慢，因为为了保证表中记录的物理顺序和索引顺序一致，在记录插入的时候，会对数据页重新排序。

  

- 非聚集索引

  表记录的排列顺序和索引的排列顺序不一致。(类似偏旁部首查字)

  1. 一个表中可以拥有多个非聚集索引。

  2. 索引的逻辑顺序与磁盘上行的物理存储顺序不同，非聚集索引在叶子节点存储的是主键和索引列，当我们使用非聚集索引查询数据时，需要拿到叶子上的主键再去表中查到想要查找的数据。这个过程就是我们所说的回表。



# 3. 建索引的几大原则

### 3.1 最左前缀匹配原则

非常重要的原则. mysql会一直向右匹配直到遇到范围查询(>、<、between、like) 就停止匹配, 复合索引的第一个, 必须先查, 才能继续



1. 如果建立(a,b)顺序的索引

+ 查询 b = 2 ，是匹配不到(a,b)索引的

+ 查询 a = 1 and b = 2 或者 a = 1  又或者  b = 2 and a = 1 都可以，因为优化器会自动调整a,b的顺序。



2. 如果建立(a,b,c,d)顺序的索引

+ a = 1 and b = 2 and c > 3 and d = 4 ，d是用不到索引的，因为c字段是一个范围查询，它之后的字段会停止匹配。



3. 如果建立(a,b,d,c)顺序的索引

+ a = 1 and b = 2 and c > 3 and d = 4 ,  索引则都可以用到，a,b,d的顺序可以任意调整。



### 3.1 最左前缀匹配原则。这是非常重要、非常重要、非常重要（重要的事情说三遍）

+ 左边的必须在才走索引!!!
+ (col1, col2, col3)这个复合索引的所有前缀 就是(col1), (col1, col2), (col1, col2, col3), 包含这些列的查询都会启用索引查询.
+ 其他所有不在最左前缀里的列都不会启用索引, 即使包含了联合索引里的部分列也不行. 即上述中的(col2), (col3), (col2, col3) 都不会启用索引去查询.
+ 注意, (col1, col3)会启用(col1)的索引查询.



### 3.2 = 和 in 可以乱序

比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。



### 3.3 尽量选择区分度高的列作为索引

区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1。（越大越好）

而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。



索引列的基数越大，索引的效果越好。例如，存放出生日期的列具有不同的值，很容易区分行，而用来记录性别的列，只有"M"和"F",则对此进行索引没有多大用处，因此不管搜索哪个值，都会得出大约一半的行。



### 3.4 索引列不能参与计算，保持列“干净”，

比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。



### 3.5 尽量的扩展索引，不要新建索引。

比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。



### 3.6 在合适的列上创建索引

可以考虑使用索引的主要有两种类型的列：在where子句中出现的列, 在join子句中出现的列

而不是在SELECT关键字后选择列表的列



### 3.7 使用短索引

如果对字符串列进行索引，应该指定一个前缀长度，可节省大量索引空间，提升查询速度；

例如，有一个CHAR(200)列，如果在前10个或20个字符内，多数值是唯一的，那么就不要对整个列进行索引。对前10个或者20个字符进行索引能够节省大量索引空间，也可能会使查询更快。



### 3.8 强制类型转换会用不到索引

phone varchar(20),   index(phone)

```sql
select phone where phone = '1000000' # 用到索引
select phone where phone = 1000000   # 用不到索引
```



### 3.9 索引的列不允许为 null

也能建立索引, 但是会造成不符合预期的行为



### 3.10 索引数量控制

+ 单表索引控制在5个以内

+ 复合索引字段最好不超过5个



### 3.11 离散度更高的索引应该放在联合索引的前面。

因为离散度高索引的可选择性高

```sql
SELECT count(DISTINCT user_id), count(DISTINCT lottery_id), count(DISTINCT award_id) FROM lottery_user_log
```

看下面的结果, 越大的适合在前面

```
count(DISTINCT user_id),count(DISTINCT lottery_id),count(DISTINCT award_id) 
56135										 1													12

适合创建 (user_id, award_id, lottery_id)
```

  

# 4. BTree和 B+Tree

为了减少磁盘I/O。磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。

这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。

预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k）。 InnoDB 引擎一个页的大小是 16K。(mysql5.7后，提供了一个设定page大小的参数innodb_page_size，默认值是16K。)

![1](mysql索引介绍/1.png)

### 4.1 为什么选用 BTree

实际实现B-Tree还需要使用如下技巧：

每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。

B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)O(h)=O(logdN)。一般实际应用中，出度d(节点数)是非常大的数字，通常超过100，因此h非常小（通常不超过3）。

而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。



### 4.2 B 树（也就是 B- 树）

- 关键字分布在整棵树的所有节点。
- 任何一个关键字 出现且只出现在一个节点中。
- 搜索有可能在 非叶子节点 结束。
- 其搜索性能等价于在关键字全集内做一次二分查找。如下图所示：

![1](mysql索引介绍/2.png)

### 4.3 B+ 树

- 非叶子节点的子树指针与关键字个数相同。
- 非叶子节点的子树指针 P[i]，指向关键字属于 [k[i],K[i+1]) 的子树（注意：区间是前闭后开)。
- 为所有叶子节点增加一个链指针。
- 所有关键字都在叶子节点出现。

![1](mysql索引介绍/3.png)



### 4.4  B+ 树存储多少数据

InnoDB存储引擎它也是有最小存储单位的，叫做页（Page），默认大小是16kb。

InnoDB存储引擎最小存储单元是页，在B+树索引结构里，页可以放一行一行的数据（叶子节点），也可以放主键+指针（非叶子节点）。



假如一行数据大小是1k，那么理论上一页就可以放16条数据。那一页可以放多少主键+指针呢？

假如我们的主键id为bigint类型，长度为8字节，而指针大小在InnoDB源码中设置为6字节。这样算下来就是 16384 / 14 = 1170，就是说一个页上可以存放1170个指针。

一个指针指向一个存放记录的页，一个页里可以放16条数据，那么一颗高度为2的B+树就可以存放 1170 * 16=18720 条数据。同理，高度为3的B+树，就可以存放 1170 * 1170 * 16 = 21902400 条1k数据的记录。

理论上就是这样，在InnoDB存储引擎中，B+树的高度一般为2-4层，就可以满足千万级数据的存储。查找数据的时候，一次页的查找代表一次IO，那我们通过主键索引查询的时候，其实最多只需要2-4次IO就可以了。

但是每个页不可能只放数据本身。首先每个页都有一些固定的格式，比如文件头部、页面头部、文件尾部这些，所以实际会比较少一些。



实际测试中发现:  数据大概在1300万左右，B+树就会增加树高到4层。



### 4.5 相对 B 树，B+ 树做索引的优势

B+树的高度比较稳定，因为它的非叶子节点不会保存数据，只保存键值和指针的情况下，一个页能承载大量的数据。

B树它的非叶子节点也会保存数据的，同样的一行数据大小是1kb，那么它一页最多也只能保存16个指针，在大量数据的情况下，树高就会速度膨胀，导致IO次数就会很多，查询就会变得很慢。



1. B+ 树的磁盘读写代价更低。

   B+ 树的内部没有指向关键字具体信息的指针，所以其内部节点相对 B 树更小，如果把所有关键字存放在同一块盘中，那么盘中所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相应的，IO 读写次数就降低了。

2. 树的查询效率更加稳定。

   B+ 树所有数据都存在于叶子节点，所有关键字查询的路径长度相同，每次数据的查询效率相当。而 B 树可能在非叶子节点就停止查找了，所以查询效率不够稳定。

3. B+ 树只需要去遍历叶子节点就可以实现整棵树的遍历。



### 4.6 MongoDB 的索引 B 树，而 MySQL 的索引 B+ 树？

因为 MongoDB 不是传统的关系型数据库，而是以 Json 格式作为存储的 NoSQL 非关系型数据库，目的就是高性能、高可用、易扩展。摆脱了关系模型，所以范围查询和遍历查询的需求就没那么强烈了。



# 5. MyISAM 和 InnoDB 的B+Tree区别

都是用 B+树实现的

![1](mysql索引介绍/4.png)

### 5.1 MyISAM 非聚集索引

1. MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。

2. 非聚簇索引的主键索引和辅助索引两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已

   主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。

3. 表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。

   由于索引树是独立的，通过辅助键检索无需访问主键的索引树。

4. 索引文件（.MYI）和数据文件（.MYD）文件是分离的,  索引文件仅保存数据记录的地址(指针去查找)。



### 5.2 InnoDB 聚集索引 

1. InnoDB的数据文件本身就是索引文件。

2. 如果一个主键被定义了，那么这个主键就是作为聚集索引。

3. 如果没有主键被定义，那么该表的第一个唯一非空索引被作为聚集索引。

4. 如果没有主键也没有合适的唯一索引，那么innodb内部会生成一个隐藏的主键作为聚集索引，这个隐藏的主键是一个6个字节的列，改列的值会随着数据的插入自增。

5. 因此建议是给每个表都定一个主键。如果该表没有逻辑主键，则创建一个自增的列作为主键。



### 5.3 总结

例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。

再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段int作为主键则是一个很好的选择。



# 6. 头脑风暴

### 6.1 B+树

走索引是从上往下

全表扫描是从左往右

### 6.2 聚集索引理解

+ 只能有一个聚集索引, 索引和数据在一起

+ 其他的索引就做辅助索引, 走索引后,找到的数据时在用聚集索引, 再次回表查询



# 7. 参考资料

+ https://tech.meituan.com/2014/06/30/mysql-index.html
+ https://www.infoq.cn/article/OJKWYykjoyc2YGB0Sj2c
+ https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html